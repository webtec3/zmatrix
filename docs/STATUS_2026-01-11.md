# Status 2026-01-11

## Contexto geral
- Projeto: extensao PHP C++/CUDA em `\\wsl$\Ubuntu\home\omgaalfa\php-projetos\php-extension\zmatrix`
- Stack: C++17, PHP extension, OpenMP, SIMD (AVX2/AVX512), CUDA (WSL2)
- Objetivo recente: habilitar GPU e comprovar uso real

## Decisoes e mudancas tecnicas
### SIMD
- `src/simd/simd_dispatch.h` com kernels SIMD (add/sub/mul, abs/sqrt, min/max/sum, relu/leaky, escalares)
- ZTensor usa SIMD para tensores menores e OpenMP para grandes

### GPU baseline
- Kernels CUDA em `src/gpu_kernels.cu` + wrappers em `src/gpu_wrapper.h`
- Limiar GPU: `ZMATRIX_GPU_THRESHOLD 200000`
- Despacho GPU para add/sub/mul/relu/sigmoid/tanh/exp/abs e escalares
- Debug GPU: `ZMATRIX_GPU_DEBUG=1`

### Build/link CUDA
- `config.m4` ajustado para `PHP_ADD_MAKEFILE_FRAGMENT([src/Makefile.frag])`
- `src/Makefile.frag`: `shared_objects_zmatrix += gpu_kernels.o`
- Corrigiu erro `undefined symbol: gpu_available`

### WSL/CUDA runtime
- CUDA OK no WSL, mas PHP nao via GPU sem `LD_LIBRARY_PATH=/usr/lib/wsl/lib`
- `cuda_probe.cu` retorna `n=1` (GPU OK)
- `ldconfig` com `/usr/lib/wsl/lib` nem sempre resolve para PHP

### Cache de buffers CUDA
- Cache simples `d_a/d_b` em `gpu_kernels.cu` para reduzir `cudaMalloc/cudaFree`
- Overhead de copia ainda domina quando host<->device a cada operacao

### Tensores residentes na GPU (opcao escolhida)
- ZTensor com buffer device:
  - campos: `d_data`, `d_capacity`, `device_valid`, `host_valid`
  - metodos: `to_gpu()`, `to_cpu()`, `is_on_gpu()`, `ensure_device()`, `ensure_host()`, `free_device()`
- Metodos PHP: `toGpu()`, `toCpu()`, `isOnGpu()`
- Kernels device-only (`*_device`) adicionados
- Operacoes add/sub/mul/relu/leaky/sigmoid/tanh/exp/abs + escalares usam device quando `device_valid = true`
- Leitura/convert para PHP e reducoes fazem `ensure_host()`

## Testes criados
- `test_gpu_ops.php`: benchmark com warmup + avg/min/max + compare GPU/CPU
- `test_gpu_vs_cpu.php`: compare GPU/CPU com speedup real
- `test_gpu_resident.php`: benchmark com tensores residentes

## Resultados observados
- Sem residencia: GPU ~ CPU (ou pior) por overhead de copia
- Com residencia (e `LD_LIBRARY_PATH`): tempos sub-ms em ops elementwise
- Sem `LD_LIBRARY_PATH` no PHP: `cudaMalloc: no CUDA-capable device is detected`

## Pendencias criticas
### Stubs desatualizados
**Faltam no stub e existem na extensao**
- `__toString`, `shape`, `ndim`, `size`, `isEmpty`
- `arr`, `random`, `identity`, `eye`, `logspace`
- `sumtotal`, `sigmoidDerivative`, `softmaxDerivative`, `reluDerivative`, `tanhDerivative`, `leakyReluDerivative`
- `dot`, `broadcast`, `greater`, `minimum`, `maximum`, `key`, `tile`, `safe`
- `toGpu`, `toCpu`, `isOnGpu`

**Estao no stub mas nao existem**
- `empty`, `rand` (na extensao e `random`)
- `getShape/getSize/getNDim/getDType`
- `reshape_inplace/flatten/flatten_inplace/transpose_inplace`
- `subtract/multiply` (na extensao sao `sub/mul`)
- `scalarAdd/scalarSubtract` (na extensao usa `add/sub` com escalar)
- `var/prod/cumsum/cumprod/argmin/argmax`
- `log10/sign/sin/cos/tan/sinh/cosh/tanh_activation`
- `unique/sort/concatenate/clone`

### Runtime
- PHP ainda depende de `LD_LIBRARY_PATH=/usr/lib/wsl/lib` para ver GPU
- Opcao: rpath `/usr/lib/wsl/lib` no build

## Progresso atual
- GPU residente implementado
- Metodos PHP de GPU adicionados
- Benchmarks rodando com `LD_LIBRARY_PATH`

## Proximos passos sugeridos
1) Atualizar `ztensor.stub.php` e `zmatrix.stub.php` + regenerar arginfo
2) Fix definitivo do loader (rpath) para nao depender de `LD_LIBRARY_PATH`
3) Expandir ops residentes (divide/pow/softmax/reducoes) conforme necessario
